lua require('plugins')

" call plug#begin('~/.vim/bundle')
"
"
"
" call plug#end()


" Set updatetime for CursorHold
" 300ms of no cursor movement to trigger CursorHold
" set updatetime=300
" Show diagnostic popup on cursor hold
" autocmd CursorHold * lua vim.lsp.diagnostic.show_line_diagnostics()

" let g:completion_chain_complete_list = [
"     \{'complete_items': ['lsp', 'snippet', 'buffers']},
"     \{'mode': '<c-p>'},
"     \{'mode': '<c-n>'}
" \]

" let g:completion_enable_auto_popup = 0
" Use <Tab> and <S-Tab> to navigate through popup menu
" inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" Set completeopt to have a better completion experience
" set completeopt=menuone,noinsert,noselect


" Avoid showing message extra message when using completion
" set shortmess+=c

set completeopt=menuone,noselect

lua << EOF
-- require'lightspeed'.setup { }


-- require('gitsigns').setup()

require'compe'.setup {
  enabled = true;
  autocomplete = true;
  debug = false;
  min_length = 1;
  preselect = 'enable';
  throttle_time = 80;
  source_timeout = 200;
  resolve_timeout = 800;
  incomplete_delay = 400;
  max_abbr_width = 100;
  max_kind_width = 100;
  max_menu_width = 100;
  documentation = {
    border = { '', '' ,'', ' ', '', '', '', ' ' }, -- the border option is the same as `|help nvim_open_win|`
    winhighlight = "NormalFloat:CompeDocumentation,FloatBorder:CompeDocumentationBorder",
    max_width = 120,
    min_width = 60,
    max_height = math.floor(vim.o.lines * 0.3),
    min_height = 1,
  };

  source = {
    path = true;
    buffer = true;
    calc = true;
    nvim_lsp = true;
    nvim_lua = true;
    vsnip = true;
    ultisnips = false;
    luasnip = false;
  };
}

local t = function(str)
  return vim.api.nvim_replace_termcodes(str, true, true, true)
end

local check_back_space = function()
    local col = vim.fn.col('.') - 1
    return col == 0 or vim.fn.getline('.'):sub(col, col):match('%s') ~= nil
end

-- Use (s-)tab to:
--- move to prev/next item in completion menuone
--- jump to prev/next snippet's placeholder
_G.tab_complete = function()
  if vim.fn.pumvisible() == 1 then
    return t "<C-n>"
  elseif vim.fn['vsnip#available'](1) == 1 then
    return t "<Plug>(vsnip-expand-or-jump)"
  elseif check_back_space() then
    return t "<Tab>"
  else
    return vim.fn['compe#complete']()
  end
end
_G.s_tab_complete = function()
  if vim.fn.pumvisible() == 1 then
    return t "<C-p>"
  elseif vim.fn['vsnip#jumpable'](-1) == 1 then
    return t "<Plug>(vsnip-jump-prev)"
  else
    -- If <S-Tab> is not working in your terminal, change it to <C-h>
    return t "<S-Tab>"
  end
end

vim.api.nvim_set_keymap("i", "<Tab>", "v:lua.tab_complete()", {expr = true})
vim.api.nvim_set_keymap("s", "<Tab>", "v:lua.tab_complete()", {expr = true})
vim.api.nvim_set_keymap("i", "<S-Tab>", "v:lua.s_tab_complete()", {expr = true})
vim.api.nvim_set_keymap("s", "<S-Tab>", "v:lua.s_tab_complete()", {expr = true})


local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities.textDocument.completion.completionItem.snippetSupport = true
capabilities.textDocument.completion.completionItem.resolveSupport = {
  properties = {
    'documentation',
    'detail',
    'additionalTextEdits',
  }
}

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  --Enable completion triggered by <c-x><c-o>
  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  local opts = { noremap=true, silent=true }

  -- See `:help vim.lsp.*` for documentation on any of the below functions
  buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', '<C-m>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', '<C-w>', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
  buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
  buf_set_keymap('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)
  buf_set_keymap('n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)
end

local lspconfig = require'lspconfig'

lspconfig.vimls.setup({
  capabilities = capabilities,
  on_attach = on_attach
})

require('rust-tools').setup({
  server = {
    capabilities = capabilities,
    on_attach = on_attach
  }
})

require('rust-tools.inlay_hints').set_inlay_hints()

-- require'lspconfig'.rust_analyzer.setup({
--   on_attach = on_attach,
-- })

-- local servers = { 'vim-language-server', 'rust_analyzer' }
-- for _, lsp in ipairs(servers) do
--   nvim_lsp[lsp].setup {
--     on_attach = on_attach,
--     capabilities = capabilities,
--     flags = {
--       debounce_text_changes = 150,
--     }
--   }
-- end

-- require'lspconfig'.rust_analyzer.setup{on_attach=require'completion'.on_attach}

-- local cmp = require'cmp'
-- cmp.setup({
--   snippet = {
--     expand = function(args)
--       vim.fn["vsnip#anonymous"](args.body)
--     end,
--   },
--   mapping = {
--       ['<C-d>'] = cmp.mapping.scroll_docs(-4),
--       ['<C-f>'] = cmp.mapping.scroll_docs(4),
--       ['<C-Space>'] = cmp.mapping.complete(),
--       ['<C-e>'] = cmp.mapping.close(),
--       ['<CR>'] = cmp.mapping.confirm({
--         behavior = cmp.ConfirmBehavior.Replace,
--         select = true,
--       })
--   },
--   sources = {
--   }
-- })


-----------------------------------
-- -- TODO COMPLETION
-- local nvim_lsp = require('lspconfig')
--




-- -- TODO: is this duplicate of the inlay hints that already work?
--
--
-- local function setup_servers()
--   require'lspinstall'.setup()
--   local servers = require'lspinstall'.installed_servers()
--   -- for _, server in pairs(servers) do
--   --   nvim_lsp[server].setup{
--   --     on_attach = on_attach,
--   --     flags = {
--   --       debounce_text_changes = 150,
--   --     }
--   --   }
--   -- end
--

-- end

-- setup_servers()
--
-- -- Automatically reload after `:LspInstall <server>` so we don't have to restart neovim
-- require'lspinstall'.post_install_hook = function ()
--   setup_servers() -- reload installed servers
--   vim.cmd("bufdo e") -- this triggers the FileType autocmd that starts the server
-- end
--
--
-- -- Enable diagnostics
-- vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
--   vim.lsp.diagnostic.on_publish_diagnostics, {
--     virtual_text = true,
--     signs = true,
--     update_in_insert = false,
--     severity_sort = true,
--   }
-- )
-----------------------------------
-----------------------------------
-----------------------------------
-----------------------------------
-----------------------------------





-- require'nvim-treesitter.configs'.setup {
--   ensure_installed = { "rust" }, -- one of "all", "maintained" (parsers with maintainers), or a list of languages
--   ignore_install = { "javascript" }, -- List of parsers to ignore installing
--   highlight = {
--     enable = true,              -- false will disable the whole extension
--     disable = { },  -- list of language that will be disabled
--     -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
--     -- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
--     -- Using this option may slow down your editor, and you may see some duplicate highlights.
--     -- Instead of true it can also be a list of languages
--     additional_vim_regex_highlighting = false,
--   },
-- }


require'nvim-treesitter.configs'.setup {
  ensure_installed = {"c", "cpp", "json", "javascript", "go", "python", "rust", "query", "lua"},
  highlight = {
    enable = true,
  },
  incremental_selection = {
    enable = true,
    keymaps = {
      init_selection = "gnn",
      node_incremental = "grn",
      scope_incremental = "rc",
      node_decremental = "grm",
    },
  },
  textobjects = {
      select = {
        enable = true,
        keymaps = {
          -- You can use the capture groups defined in textobjects.scm
          ["af"] = "@function.outer",
          ["if"] = "@function.inner",
          ["ac"] = "@class.outer",
          ["ic"] = "@class.inner",

          -- Or you can define your own textobjects like this
          ["iF"] = {
            python = "(function_definition) @function",
            cpp = "(function_definition) @function",
            c = "(function_definition) @function",
            java = "(method_declaration) @function",
          },
        },
      },
  move = {
      enable = true,
      goto_next_start = {
        ["]a"] = "@function.outer",
        ["]]"] = "@class.outer",
      },
      goto_next_end = {
        ["]A"] = "@function.outer",
        ["]["] = "@class.outer",
      },
      goto_previous_start = {
        ["[a"] = "@function.outer",
        ["[["] = "@class.outer",
      },
      goto_previous_end = {
        ["[A"] = "@function.outer",
        ["[]"] = "@class.outer",
      },
    },

  swap = {
      enable = true,
      swap_next = {
        ["<leader>a"] = "@parameter.inner",
      },
      swap_previous = {
        ["<leader>A"] = "@parameter.inner",
      },
    },
    },
}

-- require('lsp_extensions').inlay_hints{ enabled = {"TypeHint", "ChainingHint", "ParameterHint"} }

-- -- Get the counts from your curreent workspace:
-- local ws_errors = require('lsp_extensions.workspace.diagnostic').get_count(0, 'Error')
-- local ws_hints = require('lsp_extensions.workspace.diagnostic').get_count(0, 'Hint')
--
-- -- Set the qflist for the current workspace
-- --  For more information, see `:help vim.lsp.diagnostic.set_loc_list()`, since this has some of the same configuration.
-- require('lsp_extensions.workspace.diagnostic').set_qf_list()

EOF



inoremap <silent><expr> <C-Space> compe#complete()
" inoremap <silent><expr> <CR>      compe#confirm('<CR>')
inoremap <silent><expr> <C-e>     compe#close('<C-e>')
inoremap <silent><expr> <C-f>     compe#scroll({ 'delta': +4 })
inoremap <silent><expr> <C-d>     compe#scroll({ 'delta': -4 })

" Expand
imap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'
smap <expr> <C-j>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-j>'

" Expand or jump
imap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'
smap <expr> <C-l>   vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'


" Enable type inlay hints
" autocmd CursorMoved,InsertLeave,BufEnter,BufWinEnter,TabEnter,BufWritePost *
" \ lua require'lsp_extensions'.inlay_hints{ prefix = '', highlight = "Comment", enabled = {"TypeHint", "ChainingHint", "ParameterHint"} }

set synmaxcol=7000

" TODO: add back yapf when https://github.com/sbdchd/neoformat/issues/126 is fixed
let g:neoformat_enabled_python = ['autopep8', 'docformatter', 'black']
" let g:neoformat_enabled_python = ['autopep8', 'docformatter']
let g:neoformat_run_all_formatters = 1

let mapleader=','
let maplocalleader=','

let g:VimuxOrientation = 'h'

" Allow backgrounding buffers without writing them, and remember marks/undo
" for backgrounded buffers
set hidden
set scrolloff=9

set nonumber
set norelativenumber
set noshowmode

" Set encoding
set encoding=utf-8
set fileencoding=utf-8
set termencoding=utf-8
set fileencodings=ucs-bom,utf8,latin2 " ,latin1,default

" Whitespace stuff
set nowrap
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab

" TODO - does this help things?
" set smartindent

set list listchars=tab:--,trail:.

set backupcopy=yes

set hlsearch
set incsearch

" Make searches case-sensitive only if they contain upper-case characters
set ignorecase
set smartcase
nnoremap <CR> :nohlsearch<CR>/<BS>

" TODO - how does this differ from "longest,list" only?
" Tab completion
set wildmode=list:longest,list:full
set wildignore+=obj,*.o,*.obj,.git,*.rbc,*.class,.svn,vendor/gems/*,node_modules,tmp,project/target,target,tags,CMakeFiles,bower_components,dist,_darcs,vcr,app/assets/images,*.dSYM,*.pyc,_build,rel,*.a,priv/static,*.aux,*.dvi,*.xmpi,*.out,*.lot,*.lof,*.blg,*.bbl,*.toc,__pycache__,build,logs,tags
let NERDTreeRespectWildIgnore=1

" TODO - what is the default behavior?
" Remap the tab key to do autocompletion or indentation depending on the
" context (from http://www.vim.org/tips/tip.php?tip_id=102)
" function! InsertTabWrapper()
"     let col = col('.') - 1
"     if !col || getline('.')[col - 1] !~ '\k'
"         return "\<tab>"
"     else
"         return "\<c-p>"
"     endif
" endfunction
"
" inoremap <tab> <c-r>=InsertTabWrapper()<cr>
" inoremap <s-tab> <c-n>

command! W :w

cmap w!! w !sudo tee > /dev/null %

" Status bar
set winwidth=75

" Use modeline overrides
set modeline
set modelines=10

set t_Co=256
set background=dark
" set termguicolors

let base16colorspace=256  " Access colors present in 256 colorspace
" color base16-material-palenight
color base16-default
" color Tomorrow-Night-Eighties

" Directories for swp files
set backupdir=~/.vim/backup
set directory=~/.vim/backup

" Remember last location in file
aug last_location
  au!
  au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal g'\"" | endif
aug END

" Save undo history
if has('persistent_undo')
  set undofile
  if !isdirectory($HOME . '/.vimundo')
    silent !mkdir ~/.vimundo > /dev/null 2>&1
  endif
  set undodir=~/.vimundo
endif

" allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Show (partial) command in the status line
set showcmd

set cursorline
set nocursorcolumn

if has('gui_running')
  " Automatically resize splits when resizing MacVim window
  aug vim_gui_resized
    autocmd!
    autocmd VimResized * wincmd =
  aug END

  set visualbell
  set lines=40
  set columns=120

  " Remove scrollbars
  set guioptions-=L
  set guioptions-=r
  set guioptions-=T
endif


" Buffer resizing with arrow keys
nnoremap <Up> <C-w>5-
nnoremap <Down> <C-w>5+
nnoremap <Left> <C-w>5<
nnoremap <Right> <C-w>5>

" nnoremap - :Switch<cr>
nnoremap - :Neoformat<cr>
" nnoremap - :RustFmt<cr>

nnoremap ; :
" nnoremap : ;

nnoremap <leader>ge :e ~/.vimrc<CR>


" Expand %% to directory path of current buffer
cnoremap %% <C-R>=expand('%:h').'/'<CR>
nnoremap <Leader>e :call VimuxRunCommand("make")<cr>
nnoremap <F5> :call VimuxRunCommand("make")<cr>
nnoremap <F4> :call VimuxRunCommand("make")<cr>
" nnoremap <leader>r :call VimuxRunCommand("make ". expand("%h"))<cr>
nnoremap <leader>r :call VimuxRunCommand("make test")<cr>
nnoremap <leader>c :call VimuxRunCommand("make clean")<cr>

" Inserts the path of the currently edited file in command mode
cnoremap <C-P> <C-R>=expand("%:p:h") . "/" <CR>

" Open files with <leader>f
noremap <leader>f  :Files ./<CR>
" Open files, limited to the directory of the current files, with <leader>gf
noremap <leader>F  :FZF %%<CR>

nnoremap <leader>gt :Tags<cr>
nnoremap <leader>ga :Rg<cr>
nnoremap <leader>gd :Rg <C-r><C-w><cr>

nnoremap <leader>b :Buffers<cr>
nnoremap <leader>B :BTags<cr>

nnoremap <C-a> ^
nnoremap <C-e> $

" TODO: figure out how to remap these?
" nunmap ]f
" nunmap [f

inoremap <C-a> <Home>
inoremap <C-e> <End>

" For easier navigation between windows
nnoremap <C-j> <C-w><C-j>
nnoremap <C-k> <C-w><C-k>
nnoremap <C-h> <C-w><C-h>
nnoremap <C-l> <C-w><C-l>

vnoremap - :Neoformat<cr>

" Bubble multiple lines
vnoremap <C-Up> <C-w><C-k>
vnoremap <C-Down> <C-w><C-j>
vnoremap <C-Left> <C-w><C-h>
vnoremap <C-Right> <C-w><C-l>

" fat fingers
noremap <F1> <Esc>

inoremap <C-X><C-@> <C-A>

" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)

" Insert mode completion
" imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
" imap <c-x><c-l> <plug>(fzf-complete-line)

xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" Disable accidental ex mode
nmap Q <NOP>

" Switching between active files in a buffer.
nnoremap <leader><leader> <c-^>

" CTags - TODO - find a good hotkey for this
" # TODO: ignore from a file?
noremap <leader>lt :!ctags --extras=+f --exclude=build --exclude=public --exclude=target --exclude=node_modules --exclude=.git -R *<CR>
noremap <C-\> :tnext<CR>

noremap <silent> <leader>y :<C-u>silent '<,'>w !pbcopy<CR>

" https://github.com/junegunn/fzf.vim/issues/544
" if has('nvim')
"   au TermOpen * tnoremap <Esc> <c-\><c-n>
"   au TermOpen * tnoremap <C-c> <c-\><c-n>
"   au TermOpen * tnoremap <C-g> <c-\><c-n>
"   au FileType fzf tunmap <Esc>
" endif

if has("nvim")
  au TermOpen * tnoremap <buffer> <Esc> <c-\><c-n>
  au FileType fzf tunmap <buffer> <Esc>
endif

" TODO m1 ... bug? disabled for now
" au FileType fzf tunmap <Esc>
" au FileType fzf tunmap <C-c>
" au FileType fzf tunmap <C-g>
" TODO m1 ... bug?


" augroup fmt
"   autocmd!
"   autocmd BufWritePre *.go undojoin | Neoformat
" augroup END

let g:jedi#smart_auto_mappings = 0

aug various_file_types
  autocmd!
  " Rakefile, Vagrantfile and Gemfile are Ruby
  autocmd BufRead,BufNewFile {Capfile,Gemfile,Rakefile,Vagrantfile,config.ru} set ft=ruby
  autocmd BufRead,BufNewFile *.asm set ft=nasm

  " add json syntax highlighting
  " autocmd BufNewFile,BufRead *.tsx,*.jsx set filetype=typescript.tsx

  autocmd BufNewFile,BufRead *.slime set filetype=slim

  autocmd BufNewFile,BufRead *.conf set filetype=conf
  autocmd BufNewFile,BufRead *vimrc set filetype=vim

  autocmd BufNewFile,BufRead *.md set wrap
  autocmd BufNewFile,BufRead *.markdown inoremap <buffer>_ \_
  autocmd BufNewFile,BufRead *.markdown inoremap <buffer>\\ \\\\\\\\
  autocmd BufNewFile,BufRead *.markdown inoremap <buffer><C-b> \boldsymbol
  " autocmd BufNewFile,BufRead *.markdown inoremap <buffer><C-m> \mathcal

  autocmd BufWritePost .Xresources,Xresources silent execute '!xrdb ~/.Xresources' | redraw | echom 'Xresources reloaded'
aug END

" remove unnecessary whitespaces
noremap <leader>ws :%s/ *$//g<cr><c-o><cr>

set pastetoggle=<F3>
set mouse-=a

nnoremap <F9> :Neogit<CR>

" nnoremap <F7> :set keymap=czech-qwerty<CR>
" nnoremap <F8> :set keymap=<CR>
" inoremap <F7> <C-o>:set keymap=czech-qwerty<CR>
" inoremap <F8> <C-o>:set keymap=<CR>

nnoremap <F12> :e ++enc=iso-8859-2<CR>

au BufRead,BufNewFile */funcs/* setfiletype zsh

autocmd BufNewFile,BufRead * :normal zz

let g:limelight_paragraph_span = 2
" autocmd BufRead,BufNewFile * Limelight 0.5

" Include user's local vim config
if filereadable(expand('~/.vimrc.local'))
  source ~/.vimrc.local
endif

if has('user_commands')
  command! -bang -nargs=? -complete=file E e<bang> <args>
  command! -bang -nargs=? -complete=file W w<bang> <args>
  command! -bang -nargs=? -complete=file Wq wq<bang> <args>
  command! -bang -nargs=? -complete=file WQ wq<bang> <args>
  command! -bang Wa wa<bang>
  command! -bang WA wa<bang>
  command! -bang Q q<bang>
  command! -bang QA qa<bang>
  command! -bang Qa qa<bang>
endif

"alphsubs ---------------------- {{{
        execute "digraphs ks " . 0x2096
        execute "digraphs as " . 0x2090
        execute "digraphs es " . 0x2091
        execute "digraphs hs " . 0x2095
        execute "digraphs is " . 0x1D62
        execute "digraphs ks " . 0x2096
        execute "digraphs ls " . 0x2097
        execute "digraphs ms " . 0x2098
        execute "digraphs ns " . 0x2099
        execute "digraphs os " . 0x2092
        execute "digraphs ps " . 0x209A
        execute "digraphs rs " . 0x1D63
        execute "digraphs ss " . 0x209B
        execute "digraphs ts " . 0x209C
        execute "digraphs us " . 0x1D64
        execute "digraphs vs " . 0x1D65
        execute "digraphs xs " . 0x2093
"}}


function! s:profilestop()
  profdel func *
  profdel file *
  " qa!
endfunction

function! s:profilestart()
  profile start vim.profile
  profile func *
  profile file *
endfunction


func! GodotSettings() abort
    setlocal foldmethod=expr
    setlocal tabstop=4 noexpandtab autoindent shiftwidth=4
endfunc
augroup godot | au!
    au FileType gdscript call GodotSettings()
augroup end


" set foldmethod=expr
" set foldexpr=nvim_treesitter#foldexpr()


command! -nargs=0 StartProfiling call s:profilestart()
command! -nargs=0 StopProfiling call s:profilestop()

set exrc
set secure
